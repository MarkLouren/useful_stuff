==== Document Object Model, сокращённо DOM – объектная модель документа, которая представляет все содержимое 
страницы в виде объектов, которые можно менять.

SPEC: https://dom.spec.whatwg.org.
http://software.hixie.ch/utilities/js/live-dom-viewer/ 

==== Объектная модель браузера (Browser Object Model, BOM) – это дополнительные объекты, 
предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.

              <!-- NAVIGATION -->

getElementsBy* - возвращает живую коллекцию
 querySelectorAll - возыращает статическую коллекцию


=> <HTML> = document.documentElement 
=> <BODY> = document.body

=> elem.childNodes[0] === elem.firstChild
=> elem.childNodes[elem.childNodes.length - 1] === elem.lastChild
  
  -  children – только дочерние узлы-элементы, то есть соответствующие тегам.
  -  firstElementChild, lastElementChild – соответственно, первый и последний дети-элементы.
  -  previousElementSibling, nextElementSibling – соседи-элементы.
  -  parentElement – родитель-элемент.
  
=> document.getElementbyId(id)
// получить элемент  => let elem = document.getElementById('elem');
=> elem.querySelectorAll(css),// он возвращает все элементы внутри elem, удовлетворяющие данному CSS-селектору.
            EX:  let elements = document.querySelectorAll('ul > li:last-child');
=> elem.querySelector(css) //возвращает первый элемент, соответствующий данному CSS-селектору. 
=> elem.matches(css) // ничего не ищет, а проверяет, удовлетворяет ли elem CSS-селектору, и возвращает true или false.

EXAMPLE:
  <a href="http://example.com/file.zip">...</a>
<a href="http://ya.ru">...</a>
<script>
  // может быть любая коллекция вместо document.body.children
  for (let elem of document.body.children) {
    if (elem.matches('a[href$="zip"]')) {
      alert("Ссылка на архив: " + elem.href );
    }
  }
</script>
=>  elem.closest(css) // ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент также включается в поиск.
=> elem.getElementsByTagName(tag) //ищет элементы с данным тегом и возвращает их коллекцию. Передав "*" вместо тега, можно получить всех потомков.
=> elem.getElementsByClassName(className)  //возвращает элементы, которые имеют данный CSS-класс.
=> document.getElementsByName(name) // возвращает элементы с заданным атрибутом name.
 
=> elemA.contains(elemB) вернёт true, если elemB находится внутри elemA (elemB потомок elemA) или когда elemA==elemB.
 
 <!-- TABLES -->
 
TABLE

    table.rows – коллекция строк TR таблицы.
    table.caption/tHead/tFoot – ссылки на элементы таблицы CAPTION, THEAD, TFOOT.
    table.tBodies – коллекция элементов таблицы TBODY, по спецификации их может быть несколько.

THEAD/TFOOT/TBODY

   tbody.rows – коллекция строк TR секции.
TR
   tr.cells – коллекция ячеек TD/TH
    tr.sectionRowIndex – номер строки в текущей секции THEAD/TBODY
    tr.rowIndex – номер строки в таблице

TD/TH
    td.cellIndex – номер ячейки в строке


    
        <!-- For -->
    
    
<body>
  <div>Начало</div>

  <ul>
    <li>Информация</li>
  </ul>

  <div>Конец</div>

  <script>
    for (var i = 0; i < document.body.childNodes.length; i++) {
      alert( document.body.childNodes[i] ); // Text, DIV, Text, UL, ..., SCRIPT
    }
  </script>
  ...
</body>
 
  
                   <!-- Как примениить Метод Массива к DOM -->
 
 
 <!-- V1 -- Применить метод массива через call/apply -->
  
var elems = document.documentElement.childNodes;

[].forEach.call(elems, function(elem) {
  alert( elem ); // HEAD, текст, BODY
});
  
<!-- При помощи Array.prototype.slice сделать из коллекции массив. -->
 
 var elems = document.documentElement.childNodes;
elems = Array.prototype.slice.call(elems); // теперь elems - массив

elems.forEach(function(elem) {
  alert( elem.tagName ); // HEAD, текст, BODY
});
   
 
                 <!--  Доступ к АТРИБУТАМ DOM элемента -->
 
 Свойства 	                        Атрибуты
 
=> Любое значение                  => 	Строка
=> Названия регистрозависимы 	     =>  Не чувствительны к регистру
=> Не видны в innerHTML 	          =>  Видны в innerHTML
 
 
    elem.hasAttribute(name) – проверяет наличие атрибута
    elem.getAttribute(name) – получает значение атрибута
    elem.setAttribute(name, value) – устанавливает атрибут
    elem.removeAttribute(name) – удаляет атрибут
    elem.attributes - получить все атрибуты элемента
 
 EXAMPLE:
 
 <body>
  <div id="elem" about="Elephant"></div>

  <script>
    alert( elem.getAttribute('About') ); // (1) 'Elephant', атрибут получен

    elem.setAttribute('Test', 123); // (2) атрибут Test установлен
    alert( document.body.innerHTML ); // (3) в HTML видны все атрибуты!

    var attrs = elem.attributes; // (4) можно получить коллекцию атрибутов
    for (var i = 0; i < attrs.length; i++) {
      alert( attrs[i].name + " = " + attrs[i].value );
    }
  </script>
</body>
 
                          <!-- ClassName -->
 
 <body class="main page">
  <script>
    // прочитать класс элемента
    alert( document.body.className ); // main page

    // поменять класс элемента
    document.body.className = "class1 class2";
  </script>
</body>
 /////////  кроме className, в современных браузерах есть свойство classList.
 
 Методы classList:

    elem.classList.contains("class") – возвращает true/false, в зависимости от того, есть ли у элемента класс class.
    elem.classList.add/remove("class") – добавляет/удаляет класс class
    elem.classList.toggle("class") – если класса class нет, добавляет его, если есть – удаляет.

Кроме того, можно перебрать классы через for, так как classList – это псевдо-массив.
 
 
                   <!-- DATA -->
С помощью нестандартных атрибутов можно привязать к элементу данные, которые будут доступны в JavaScript.
Как правило, это делается при помощи атрибутов с названиями, начинающимися на data-
 
 EXAMPLE DATA, DATASET
 
 <div id="elem" data-about="Elephant" data-user-location="street">
  По улице прошёлся слон. Весьма красив и толст был он.
</div>
<script>
  alert( elem.getAttribute('data-about') ); // Elephant
  alert( elem.getAttribute('data-user-location') ); // street
 
   alert( elem.dataset.about ); // Elephant
  alert( elem.dataset.userLocation ); // street
</script>
 
====================================================
 Свойства узлов: тип, тег и содержимое
 ===================================================
 
 Существуют следующие классы:
 
 => EventTarget – это корневой «абстрактный» класс. Объекты этого класса никогда не создаются.
 Он служит основой, благодаря которой все DOM-узлы поддерживают так называемые «события», о которых мы поговорим позже.

 => Node – также является «абстрактным» классом, и служит основой для DOM-узлов. Он обеспечивает базовую функциональность: 
 parentNode, nextSibling, childNodes и т.д. (это геттеры). Объекты класса Node никогда не создаются. 
 Но есть определённые классы узлов, которые наследуют от него: 
 Text – для текстовых узлов, Element – для узлов-элементов и более экзотический Comment – для узлов-комментариев.
 
 =>Element – это базовый класс для DOM-элементов. Он обеспечивает навигацию на уровне элементов:
 nextElementSibling, children и методы поиска: getElementsByTagName, querySelector. 
 Браузер поддерживает не только HTML, но также XML и SVG. 
 
 =>HTMLElement – является базовым классом для всех остальных HTML-элементов. От него наследуют конкретные элементы:

  -   HTMLInputElement – класс для тега <input>,
  -   HTMLBodyElement – класс для тега <body>,
  -   HTMLAnchorElement – класс для тега <a>,
    …и т.д, каждому тегу соответствует свой класс, который предоставляет определённые свойства и методы.


 Класс Element служит базой для следующих классов: SVGElement, XMLElement и HTMLElement
 

 
 Рассмотрим DOM-объект для тега <input>. Он принадлежит классу HTMLInputElement.

Он получает свойства и методы из (в порядке наследования):

    HTMLInputElement – этот класс предоставляет специфичные для элементов формы свойства,
    HTMLElement – предоставляет общие для HTML-элементов методы (и геттеры/сеттеры),
    Element – предоставляет типовые методы элемента,
    Node – предоставляет общие свойства DOM-узлов,
    EventTarget – обеспечивает поддержку событий (поговорим о них дальше),
    …и, наконец, он наследует от Object, поэтому доступны также методы «обычного объекта», такие как hasOwnProperty.
 
 
 
 <!--  узнать имя класса DOM-узла  -->
 1) alert( document.body.constructor.name ); // HTMLBodyElement
 2)alert( document.body ); // [object HTMLBodyElement]
 3) alert( document.body instanceof HTMLBodyElement ); // true
 4) nodeType - Свойство nodeType позволяет узнать тип DOM-узла. Его значение – числовое: 
 1 для элементов,3 для текстовых узлов, и т.д. Только для чтения.
 
 Получив DOM-узел, мы можем узнать имя его тега из свойств nodeName и tagName:
 
 alert( document.body.nodeName ); // BODY
 alert( document.body.tagName ); // BODY
============= 
Главные свойства DOM-узла:
=============
 -> nodeType
 -> nodeName/tagName //возвращает название тега
 -> innerHTML //Внутреннее HTML-содержимое узла-элемента. Можно изменять.
 --> innerText // 
 -> outerHTML //Полный HTML узла-элемента. Запись в elem.outerHTML не меняет elem
 -> nodeValue/data // Содержимое узла-неэлемента (текст, комментарий). 
 -> textContent //Текст внутри элемента: HTML за вычетом всех <тегов>. 
 -> hidden // огда значение установлено в true, делает то же самое, что и CSS display:none
 В зависимости от своего класса DOM-узлы имеют и другие свойства
 
  
  <-- STYLES -->
    ul.style.color='green'
    
