==== Document Object Model, сокращённо DOM – объектная модель документа, которая представляет все содержимое 
страницы в виде объектов, которые можно менять.

SPEC: https://dom.spec.whatwg.org.
http://software.hixie.ch/utilities/js/live-dom-viewer/ 

==== Объектная модель браузера (Browser Object Model, BOM) – это дополнительные объекты, 
предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.

              <!-- NAVIGATION -->

getElementsBy* - возвращает живую коллекцию
 querySelectorAll - возыращает статическую коллекцию


=> <HTML> = document.documentElement 
=> <BODY> = document.body

=> elem.childNodes[0] === elem.firstChild
=> elem.childNodes[elem.childNodes.length - 1] === elem.lastChild
  
  -  children – только дочерние узлы-элементы, то есть соответствующие тегам.
  -  firstElementChild, lastElementChild – соответственно, первый и последний дети-элементы.
  -  previousElementSibling, nextElementSibling – соседи-элементы.
  -  parentElement – родитель-элемент.
  
=> document.getElementbyId(id)
// получить элемент  => let elem = document.getElementById('elem');
=> elem.querySelectorAll(css),// он возвращает все элементы внутри elem, удовлетворяющие данному CSS-селектору.
            EX:  let elements = document.querySelectorAll('ul > li:last-child');
=> elem.querySelector(css) //возвращает первый элемент, соответствующий данному CSS-селектору. 
=> elem.matches(css) // ничего не ищет, а проверяет, удовлетворяет ли elem CSS-селектору, и возвращает true или false.

EXAMPLE:
  <a href="http://example.com/file.zip">...</a>
<a href="http://ya.ru">...</a>
<script>
  // может быть любая коллекция вместо document.body.children
  for (let elem of document.body.children) {
    if (elem.matches('a[href$="zip"]')) {
      alert("Ссылка на архив: " + elem.href );
    }
  }
</script>
=>  elem.closest(css) // ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент также включается в поиск.
=> elem.getElementsByTagName(tag) //ищет элементы с данным тегом и возвращает их коллекцию. Передав "*" вместо тега, можно получить всех потомков.
=> elem.getElementsByClassName(className)  //возвращает элементы, которые имеют данный CSS-класс.
=> document.getElementsByName(name) // возвращает элементы с заданным атрибутом name.
 
=> elemA.contains(elemB) вернёт true, если elemB находится внутри elemA (elemB потомок elemA) или когда elemA==elemB.
 
 <!-- TABLES -->
 
TABLE

    table.rows – коллекция строк TR таблицы.
    table.caption/tHead/tFoot – ссылки на элементы таблицы CAPTION, THEAD, TFOOT.
    table.tBodies – коллекция элементов таблицы TBODY, по спецификации их может быть несколько.

THEAD/TFOOT/TBODY

   tbody.rows – коллекция строк TR секции.
TR
   tr.cells – коллекция ячеек TD/TH
    tr.sectionRowIndex – номер строки в текущей секции THEAD/TBODY
    tr.rowIndex – номер строки в таблице

TD/TH
    td.cellIndex – номер ячейки в строке


    
        <!-- For -->
    
    
<body>
  <div>Начало</div>

  <ul>
    <li>Информация</li>
  </ul>

  <div>Конец</div>

  <script>
    for (var i = 0; i < document.body.childNodes.length; i++) {
      alert( document.body.childNodes[i] ); // Text, DIV, Text, UL, ..., SCRIPT
    }
  </script>
  ...
</body>
 
  
                   <!-- Как примениить Метод Массива к DOM -->
 
 
 <!-- V1 -- Применить метод массива через call/apply -->
  
var elems = document.documentElement.childNodes;

[].forEach.call(elems, function(elem) {
  alert( elem ); // HEAD, текст, BODY
});
  
<!-- При помощи Array.prototype.slice сделать из коллекции массив. -->
 
 var elems = document.documentElement.childNodes;
elems = Array.prototype.slice.call(elems); // теперь elems - массив

elems.forEach(function(elem) {
  alert( elem.tagName ); // HEAD, текст, BODY
});
   
 
                 <!--  Доступ к АТРИБУТАМ DOM элемента -->
 
 Свойства 	                        Атрибуты
 
=> Любое значение                  => 	Строка
=> Названия регистрозависимы 	     =>  Не чувствительны к регистру
=> Не видны в innerHTML 	          =>  Видны в innerHTML
 
 
    elem.hasAttribute(name) – проверяет наличие атрибута
    elem.getAttribute(name) – получает значение атрибута
    elem.setAttribute(name, value) – устанавливает атрибут
    elem.removeAttribute(name) – удаляет атрибут
    elem.attributes - получить все атрибуты элемента
 
 EXAMPLE:
 
 <body>
  <div id="elem" about="Elephant"></div>

  <script>
    alert( elem.getAttribute('About') ); // (1) 'Elephant', атрибут получен

    elem.setAttribute('Test', 123); // (2) атрибут Test установлен
    alert( document.body.innerHTML ); // (3) в HTML видны все атрибуты!

    var attrs = elem.attributes; // (4) можно получить коллекцию атрибутов
    for (var i = 0; i < attrs.length; i++) {
      alert( attrs[i].name + " = " + attrs[i].value );
    }
  </script>
</body>
 
                          <!-- ClassName -->
 
 <body class="main page">
  <script>
    // прочитать класс элемента
    alert( document.body.className ); // main page

    // поменять класс элемента
    document.body.className = "class1 class2";
  </script>
</body>
 /////////  кроме className, в современных браузерах есть свойство classList.
 
 Методы classList:

    elem.classList.contains("class") – возвращает true/false, в зависимости от того, есть ли у элемента класс class.
    elem.classList.add/remove("class") – добавляет/удаляет класс class
    elem.classList.toggle("class") – если класса class нет, добавляет его, если есть – удаляет.

Кроме того, можно перебрать классы через for, так как classList – это псевдо-массив.
 
 
                   <!-- DATA -->
С помощью нестандартных атрибутов можно привязать к элементу данные, которые будут доступны в JavaScript.
Как правило, это делается при помощи атрибутов с названиями, начинающимися на data-
 
 EXAMPLE DATA, DATASET
 
 <div id="elem" data-about="Elephant" data-user-location="street">
  По улице прошёлся слон. Весьма красив и толст был он.
</div>
<script>
  alert( elem.getAttribute('data-about') ); // Elephant
  alert( elem.getAttribute('data-user-location') ); // street
 
   alert( elem.dataset.about ); // Elephant
  alert( elem.dataset.userLocation ); // street
</script>
 
====================================================
 Свойства узлов: тип, тег и содержимое
 ===================================================
 
 Существуют следующие классы:
 
 => EventTarget – это корневой «абстрактный» класс. Объекты этого класса никогда не создаются.
 Он служит основой, благодаря которой все DOM-узлы поддерживают так называемые «события», о которых мы поговорим позже.

 => Node – также является «абстрактным» классом, и служит основой для DOM-узлов. Он обеспечивает базовую функциональность: 
 parentNode, nextSibling, childNodes и т.д. (это геттеры). Объекты класса Node никогда не создаются. 
 Но есть определённые классы узлов, которые наследуют от него: 
 Text – для текстовых узлов, Element – для узлов-элементов и более экзотический Comment – для узлов-комментариев.
 
 =>Element – это базовый класс для DOM-элементов. Он обеспечивает навигацию на уровне элементов:
 nextElementSibling, children и методы поиска: getElementsByTagName, querySelector. 
 Браузер поддерживает не только HTML, но также XML и SVG. 
 
 =>HTMLElement – является базовым классом для всех остальных HTML-элементов. От него наследуют конкретные элементы:

  -   HTMLInputElement – класс для тега <input>,
  -   HTMLBodyElement – класс для тега <body>,
  -   HTMLAnchorElement – класс для тега <a>,
    …и т.д, каждому тегу соответствует свой класс, который предоставляет определённые свойства и методы.


 Класс Element служит базой для следующих классов: SVGElement, XMLElement и HTMLElement
 

 
 Рассмотрим DOM-объект для тега <input>. Он принадлежит классу HTMLInputElement.

Он получает свойства и методы из (в порядке наследования):

    HTMLInputElement – этот класс предоставляет специфичные для элементов формы свойства,
    HTMLElement – предоставляет общие для HTML-элементов методы (и геттеры/сеттеры),
    Element – предоставляет типовые методы элемента,
    Node – предоставляет общие свойства DOM-узлов,
    EventTarget – обеспечивает поддержку событий (поговорим о них дальше),
    …и, наконец, он наследует от Object, поэтому доступны также методы «обычного объекта», такие как hasOwnProperty.
 
 
 
 <!--  узнать имя класса DOM-узла  -->
 1) alert( document.body.constructor.name ); // HTMLBodyElement
 2)alert( document.body ); // [object HTMLBodyElement]
 3) alert( document.body instanceof HTMLBodyElement ); // true
 4) nodeType - Свойство nodeType позволяет узнать тип DOM-узла. Его значение – числовое: 
 1 для элементов,3 для текстовых узлов, и т.д. Только для чтения.
 
 Получив DOM-узел, мы можем узнать имя его тега из свойств nodeName и tagName:
 
 alert( document.body.nodeName ); // BODY
 alert( document.body.tagName ); // BODY
============= 
Главные свойства DOM-узла:
=============
 -> nodeType
 -> nodeName/tagName //возвращает название тега
 -> innerHTML //Внутреннее HTML-содержимое узла-элемента. Можно изменять.
 --> innerText // 
 -> outerHTML //Полный HTML узла-элемента. Запись в elem.outerHTML не меняет elem
 -> nodeValue/data // Содержимое узла-неэлемента (текст, комментарий). 
 -> textContent //Текст внутри элемента: HTML за вычетом всех <тегов>. 
 -> hidden // огда значение установлено в true, делает то же самое, что и CSS display:none
 В зависимости от своего класса DOM-узлы имеют и другие свойства
 
  
  <-- STYLES -->
    ul.style.color='green'
  
    ====================================================================================================================
    Изменение документа
    =====================================================================================================================
    
    ===> Cоздание DOM узла:
    
    1) let div = document.createElement('div'); // создает новый элемент с заданым тегом
    2) let textNode = document.createTextNode('А вот и я');    //Cоздает новый текстовый узел с заданным текстом
    
    =====> Методы вставки: -  методы могут использоваться только для вставки DOM-узлов или текстовых фрагментов.
   
    - node.append(...nodes or strings) – добавляет узлы или строки в конец node,
    - node.prepend(...nodes or strings) – вставляет узлы или строки в начало node,
    - node.before(...nodes or strings) –- вставляет узлы или строки до node,
    -  node.after(...nodes or strings) –- вставляет узлы или строки после node,
    -  node.replaceWith(...nodes or strings) –- заменяет node заданными узлами или строками.
   
    =====> Пример:
<ol id="ol">
  <li>0</li>
  <li>1</li>
  <li>2</li>
</ol>

<script>
  
  ol.before('before'); // вставить строку "before" перед <ol>
  ol.after('after'); // вставить строку "after" после <ol>

  let liFirst = document.createElement('li');
  liFirst.innerHTML = 'prepend';
  ol.prepend(liFirst); // вставить liFirst в начало <ol>

  let liLast = document.createElement('li');
  liLast.innerHTML = 'append';
  ol.append(liLast); // вставить liLast в конец <ol>
  
</script>
    
    =========> insertAdjacentHTML/Text/ - для вставки HTML кода
    
    elem.insertAdjacentHTML(where, html) - вставляет HTML
    elem.insertAdjacentText(where, text) – такой же синтаксис, но строка text вставляется «как текст», вместо HTML
    elem.insertAdjacentElement(where, elem) – такой же синтаксис, но вставляет элемент elem
    
    
   -  "beforebegin" – вставить html непосредственно перед elem,
   -  "afterbegin" – вставить html в начало elem,
   -  "beforeend" – вставить html в конец elem,
   -   "afterend" – вставить html непосредственно после elem.
    
  Пример:
    
<div id="div"></div>
<script>
  div.insertAdjacentHTML('beforebegin', '<p>Привет</p>');
  div.insertAdjacentHTML('afterend', '<p>Пока</p>');
</script>

    =======> Удаление узла:
    
   node.remove()
    setTimeout(() => div.remove(), 1000);
   
    =======> Перестановка:
    
<div id="first">Первый</div>
<div id="second">Второй</div>
<script>
  // нет необходимости вызывать метод remove
  second.after(first); // берёт #second и после него вставляет #first
</script>
    
    =========>  Клонирование узлов: cloneNode
    
   elem.cloneNode(true) создаёт «глубокий» клон элемента – со всеми атрибутами и дочерними элементами. 
   Если мы вызовем elem.cloneNode(false), тогда клон будет без дочерних элементов.
    
   ПРИМЕР:
    
 <div class="alert" id="div">
  <strong>Всем привет!</strong> Вы прочитали важное сообщение.
</div>

<script>
  let div2 = div.cloneNode(true); // клонировать сообщение
  div2.querySelector('strong').innerHTML = 'Всем пока!'; // изменить клонированный элемент

  div.after(div2); // показать клонированный элемент после существующего div
</script>
    
    =======> DocumentFragment + Устаревшие методы вставки/удаления
    DocumentFragment является специальным DOM-узлом, который служит обёрткой для передачи списков узлов.
- parent.appendChild(node)
- parent.insertBefore(node, nextSibling)
- parent.removeChild(node)
- parent.replaceChild(newElem, node)
    
    ===>  document.write('<b>Привет из JS</b>');
    document.write(html) записывает html на страницу «прямо здесь и сейчас». 
    Чтобы добавить HTML на страницу до завершения её загрузки:
    
    ====================================================================================================================
    Стили и Классы
    ====================================================================================================================

let top = /* сложные расчёты */;
let left = /* сложные расчёты */;

elem.style.left = left; // например, '123px', значение вычисляется во время работы скрипта
elem.style.top = top; // например, '456px'
    
    
    ====> className и classList
    ==> elem.className,  заменяет всю строку с классами
    
<body class="main page">
  <script>
    alert(document.body.className); // main page
  </script>
</body>
    
    ==> elem.classList – это специальный объект с методами для добавления/удаления одного класса.
  
  <body class="main page">
  <script>
    // добавление класса
    document.body.classList.add('article');

    alert(document.body.className); // main page article
  </script>
</body>
    
   ====== Методы classList:======

  -  elem.classList.add/remove("class") – добавить/удалить класс.
  -  elem.classList.toggle("class") – добавить класс, если его нет, иначе удалить.
  -  elem.classList.contains("class") – проверка наличия класса, возвращает true/false.

Кроме того, classList является перебираемым, поэтому можно перечислить все классы при помощи for..of:
    
   <body class="main page">
  <script>
    for (let name of document.body.classList) {
      alert(name); // main, затем page
    }
  </script>
</body>
    
    =======> elem.style  - это объект, который соответствует тому, что написано в атрибуте "style". 
   
    Для свойства из нескольких слов используется camelCase:

background-color  => elem.style.backgroundColor
z-index           => elem.style.zIndex
border-left-width => elem.style.borderLeftWidth
-moz-border-radius => button.style.MozBorderRadius = '5px';
 
 ===> Сброс стилей

    EX: 
document.body.style.backgroundColor = prompt('background color?', 'green');
document.body.style.display = "none"; // скрыть
    
    Если мы установим в style.display пустую строку, то браузер применит CSS-классы и встроенные стили, 
    как если бы такого свойства style.display вообще не было.
    
 ===> style.cssText  - Для задания нескольких стилей в одной строке
    
    div.style.cssText=`color: red !important;
    background-color: yellow;
    width: 100px;
    text-align: center;
    `;
    То же самое можно сделать установкой атрибута: div.setAttribute('style', 'color: red...')

 ====>  getComputedStyle
   
    getComputedStyle(element, [pseudo])
  -   element - Элемент, значения для которого нужно получить
  -   pseudo - Указывается, если нужен стиль псевдоэлемента, 
    например ::before. Пустая строка или отсутствие аргумента означают сам элемент.
    
    EXAMPLE: 
    
<head>
  <style> body { color: red; margin: 5px } </style>
</head>
<body>
 <script>
    let computedStyle = getComputedStyle(document.body);
    // сейчас мы можем прочитать отступ и цвет
    alert( computedStyle.marginTop ); // 5px
    alert( computedStyle.color ); // rgb(255, 0, 0)
  </script>

</body>
    
    
 =====================================================================

Есть две концепции в CSS:

=> Вычисленное (computed) значение – это то, которое получено после применения всех CSS-правил и CSS-наследования.
Например, height:1em или font-size:125%.
=> Окончательное (resolved) значение – непосредственно применяемое к элементу. 
    Значения 1em или 125% являются относительными. Браузер берёт вычисленное значение и делает 
    все единицы измерения фиксированными и абсолютными, например, height:20px or font-size:16px.
    Для геометрических свойств разрешённые значения могут иметь плавающую точку, например, width:50.5px.
    
        
    ====================================================================================================================
    Размеры и прокрутка элементов
    ====================================================================================================================
    
    ==> offsetParent, offsetLeft/Top
    В свойстве offsetParent находится предок элемента, 
    который используется внутри браузера для вычисления координат при рендеринге.
    
    Свойства offsetLeft/offsetTop содержат координаты x/y относительно верхнего левого угла offsetParent.
    
    EXAMPLE:
 <main style="position: relative" id="main">
  <article>
    <div id="example" style="position: absolute; left: 180px; top: 180px">...</div>
  </article>
</main>
<script>
  alert(example.offsetParent.id); // main
  alert(example.offsetLeft); // 180 (обратите внимание: число, а не строка "180px")
  alert(example.offsetTop); // 180
</script>
    
    
    === Существует несколько ситуаций, когда offsetParent равно null:

    Для скрытых элементов (с CSS-свойством display:none или когда его нет в документе).
    Для элементов <body> и <html>.
    Для элементов с position:fixed.
    
    ====> offsetWidth/Height
    
    Они содержат «внешнюю» ширину/высоту элемента, то есть его полный размер, включая рамки.
offsetWidth = 390 – внешняя ширина блока, её можно получить сложением CSS-ширины (300px), внутренних отступов (2 * 20px) и рамок (2 * 25px).
offsetHeight = 290 – внешняя высота блока
  
    ===> clientTop/Left
    
Внутри элемента у нас рамки (border).
Для них есть свойства-метрики clientTop и clientLeft.
В нашем примере:
-  clientLeft = 25 – ширина левой рамки
-  clientTop = 25 – ширина верхней рамки

   ===> clientWidth/Height
Эти свойства – размер области внутри рамок элемента.
Они включают в себя ширину области содержимого вместе с внутренними отступами padding, но без прокрутки
- Если нет внутренних отступов padding, то clientWidth/Height в точности равны размеру области 
    содержимого внутри рамок и полосы прокрутки (если она есть).
   
  ===> scrollWidth/Height
Эти свойства – как clientWidth/clientHeight, но также включают в себя прокрученную (которую не видно) часть элемента.  
Эти свойства можно использовать, чтобы «распахнуть» элемент на всю ширину/высоту.
  EXAMPLE:
  // распахнуть элемент на всю высоту
element.style.height = `${element.scrollHeight}px`
  
  ===>scrollLeft/scrollTop
  Свойства scrollLeft/scrollTop – ширина/высота невидимой, прокрученной в данный момент, части элемента слева и сверху.
  Другими словами, свойство scrollTop – это «сколько уже прокручено вверх».
  => В отличие от большинства свойств, которые доступны только для чтения, 
 значения scrollLeft/scrollTop можно изменять, и браузер выполнит прокрутку элемента…
 При клике на следующий элемент будет выполняться код elem.scrollTop += 10. 
 Поэтому он будет прокручиваться на 10px вниз.
    
    
 ====================================================
 Размеры и прокрутка окна
 ===================================================
    Чтобы получить ширину/высоту окна, можно взять свойства clientWidth/clientHeight из document.documentElement

alert( window.innerWidth ); // полная ширина окна
alert( document.documentElement.clientWidth ); // ширина окна за вычетом полосы прокрутки
  
 ==== Чтобы надежно получить высоту документа:
    
  let scrollHeight = Math.max(
  document.body.scrollHeight, document.documentElement.scrollHeight,
  document.body.offsetHeight, document.documentElement.offsetHeight,
  document.body.clientHeight, document.documentElement.clientHeight
);

alert('Полная высота документа с прокручиваемой частью: ' + scrollHeight);

===== текущая прокрутка
alert('Текущая прокрутка сверху: ' + window.pageYOffset);
alert('Текущая прокрутка слева: ' + window.pageXOffset);

====Изменить текущую прокрутку:

window.scrollTo(pageX,pageY) – абсолютные координаты,
window.scrollBy(x,y) – прокрутка относительно текущего места,
elem.scrollIntoView(top) – прокрутить страницу так, чтобы сделать elem видимым (выровнять относительно верхней/нижней части окна

 ==== Запретить прокрутку
    
  Чтобы запретить прокрутку страницы, достаточно установить document.body.style.overflow = "hidden".
    
  ====================================================================================================================
  Координаты
  ==================================================================================================================== 
Большинство соответствующих методов JavaScript работают в одной из двух указанных ниже систем координат:
    1) Относительно окна браузера – как position:fixed, отсчёт идёт от верхнего левого угла окна.
    мы будем обозначать эти координаты как clientX/clientY
    2) Относительно документа – как position:absolute на уровне документа, отсчёт идёт от верхнего левого угла документа.
    мы будем обозначать эти координаты как pageX/pageY.
    
==>  Метод elem.getBoundingClientRect() возвращает координаты в контексте окна для минимального по размеру прямоугольника, 
который заключает в себе элемент elem, в виде объекта встроенного класса DOMRect.
      
  let coords = elem.getBoundingClientRect() 
  message.style.left = coords.left + "px";
  message.style.top = coords.bottom + "px";
    
    Основные свойства объекта типа DOMRect:

    x/y – X/Y-координаты начала прямоугольника относительно окна,
    width/height – ширина/высота прямоугольника (могут быть отрицательными).

Дополнительные, «зависимые», свойства:

    top/bottom – Y-координата верхней/нижней границы прямоугольника,
    left/right – X-координата левой/правой границы прямоугольника.
==>
    left = x
    top = y
    right = x + width
    bottom = y + height
Координаты могут быть отрицательными. Например, если страница прокручена так, что элемент elem ушёл вверх за пределы окна,
то вызов elem.getBoundingClientRect().top вернёт отрицательное значение.
  
  ======> elementFromPoint(x, y)
    
   Вызов document.elementFromPoint(x, y) возвращает самый глубоко вложенный элемент в окне,
   находящийся по координатам (x, y).
 
   let elem = document.elementFromPoint(x, y);
    
    EXAMPLE: код ниже выделяет с помощью стилей и выводит имя тега элемента, который сейчас в центре окна браузера:

let centerX = document.documentElement.clientWidth / 2;
let centerY = document.documentElement.clientHeight / 2;

let elem = document.elementFromPoint(centerX, centerY);

elem.style.background = "red";
alert(elem.tagName);
    
    
        
  ====================================================================================================================
EVENTS INTRO
  ==================================================================================================================== 
    
    Вот список самых часто используемых DOM-событий, пока просто для ознакомления:

События мыши:

    click – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).
    contextmenu – происходит, когда кликнули на элемент правой кнопкой мыши.
    mouseover / mouseout – когда мышь наводится на / покидает элемент.
    mousedown / mouseup – когда нажали / отжали кнопку мыши на элементе.
    mousemove – при движении мыши.

События на элементах управления:

    submit – пользователь отправил форму <form>.
    focus – пользователь фокусируется на элементе, например нажимает на <input>.

Клавиатурные события:

    keydown и keyup – когда пользователь нажимает / отпускает клавишу.

События документа:

    DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен.

CSS events:

    transitionend – когда CSS-анимация завершена.

     ===========================================
    Назначение:
     ===========================================
  ==>  1) В атрибуте on<событие>:
    <input value="Нажми меня" onclick="alert('Клик!')" type="button">
      OR:
   <button onclick="alert(this.innerHTML)">Нажми меня</button>
    
  ==>  2) отдельная JavaScript-функция:
    
<script>
  function countRabbits() {
    for(let i=1; i<=3; i++) {
      alert("Кролик номер " + i);
    }
  }
</script>

<input type="button" onclick="countRabbits()" value="Считать кроликов!">
    
  ==>  3) Использование свойства DOM-объекта on<событие>:
    
<input type="button" id="button" value="Кнопка">
<script>
  button.onclick = function() {
    alert('Клик!');
  };
</script>
    
    ==> 4) Специальные методы: elem.addEventListener(event, handler[, phase]) для добавления, 
    removeEventListener для удаления
    

  ===> Убрать обработчик можно назначением:
    
  elem.onclick = null
    
    ========== КАК ПРАВИЛЬНО ========
    // правильно
button.onclick = sayThanks;
   // неправильно
button.onclick = sayThanks(); // вызов функции, результат которого (равный undefined
    …А вот в разметке, в отличие от свойства, скобки нужны:
    <input type="button" id="button" onclick="sayThanks()">
    // правильно
 -  Используйте именно функции, а не строки.
 -  Не используйте setAttribute для обработчиков.
 -  Регистр DOM-свойства имеет значение.
    
         
  =========================================================================
    addEventListener - для нескольких событий на один элемент
  =========================================================================
    // установка:
    element.addEventListener(event, handler[, options]);
    
- event - Имя события, например "click".
- handler - Ссылка на функцию-обработчик.
- options:
        - once: если true, тогда обработчик будет автоматически удалён после выполнения.
        - capture: фаза, на которой должен сработать обработчик {capture: false/true}.
        - passive: если true, то указывает, что обработчик никогда не вызовет preventDefault()
    
    // удаление:
    
    element.removeEventListener(event, handler[, options]);
    
    EXAMPLE:
<input id="elem" type="button" value="Нажми меня"/>

<script>
  function handler1() {
    alert('Спасибо!');
  };

  function handler2() {
    alert('Спасибо ещё раз!');
  }

  elem.onclick = () => alert("Привет");
  elem.addEventListener("click", handler1); // Спасибо!
  elem.addEventListener("click", handler2); // Спасибо ещё раз!
</script>
    =========================================================================
    Объект события  - Когда происходит событие, браузер создаёт объект события, 
    записывает в него детали и передаёт его в качестве аргумента функции-обработчику.
  =========================================================================
 // получение координат мыши из объекта события:
    
<input type="button" value="Нажми меня" id="elem">

<script>
  elem.onclick = function(event) {
    // вывести тип события, элемент и координаты клика
    alert(event.type + " на " + event.currentTarget);
    alert("Координаты: " + event.clientX + ":" + event.clientY);
  };
</script>
    
    ==>свойства объекта event:
   - event.type - Тип события, в данном случае "click".
   - event.currentTarget - Элемент, на котором сработал обработчик. Значение – обычно такое же, как и у this.
   - event.clientX / event.clientY - Координаты курсора в момент клика относительно окна, для событий мыши.
   
    IN HTML:
    <input type="button" onclick="alert(event.type)" value="Тип события">
     =========================================================================
 Объект-обработчик: handleEvent  - обработка через   обьект а не функцию
  =========================================================================
    
    EXAMPLE:
    
   <button id="elem">Нажми меня</button>
    
<script>
  elem.addEventListener('click', {
    handleEvent(event) {
      alert(event.type + " на " + event.currentTarget);
    }
  });
</script>
    
    // через CLASS:
    
 <button id="elem">Нажми меня</button>

<script>
  class Menu {
    handleEvent(event) {
      switch(event.type) {
        case 'mousedown':
          elem.innerHTML = "Нажата кнопка мыши";
          break;
        case 'mouseup':
          elem.innerHTML += "...и отжата.";
          break;
      }
    }
  }

  let menu = new Menu();
  elem.addEventListener('mousedown', menu);
  elem.addEventListener('mouseup', menu);
</script>
    
    ЗАДАЧИ:
    
   1)  Создайте кнопку, которая будет скрывать себя по нажатию.
    
    <input type="button" onclick="this.hidden=true" value="Нажми, чтобы спрятать">
    
    2) При помощи JavaScript для каждого сообщения добавьте в верхний правый угол кнопку закрытия.
    pane.insertAdjacentHTML("afterbegin", '<button class="remove-button">[x]</button>');
    pane.firstChild.onclick = () => pane.remove();
         
  ====================================================================================================================
 ОСНОВЫ СОБЫТИЙ МЫШИ
  ==================================================================================================================== 
    Простые события

- mousedown/mouseup - Кнопка мыши нажата/отпущена над элементом.
- mouseover/mouseout - Курсор мыши появляется над элементом и уходит с него.
- mousemove - Каждое движение мыши над элементом генерирует это событие.

    Комплексные события
    
- click -Вызывается при mousedown , а затем mouseup над одним и тем же элементом, если использовалась левая кнопка мыши.
- contextmenu - Вызывается при mousedown правой кнопкой мыши.
- dblclick -Вызывается двойным кликом на элементе.

    Порядок событий: 
    
  Клик мышью вначале вызывает mousedown, когда кнопка нажата, затем mouseup и click, когда она отпущена.
    mousedown → mouseup → click
    
   ==> which - свойство позволяет определить нажатую кнопку мыши.
    Есть три возможных значения:
    - event.which == 1 – левая кнопка
    - event.which == 2 – средняя кнопка
    - event.which == 3 – правая кнопка
=======================
    Модификаторы: shift, alt, ctrl и meta
=======================
    Все события мыши включают в себя информацию о нажатых клавишах-модификаторах.
    true, если во время события была нажата соответствующая клавиша

Свойства объекта события:
    - shiftKey: Shift
    - altKey: Alt (или Opt для Mac)
    - ctrlKey: Ctrl
    - metaKey: Cmd для Mac

EXAMPLE: кнопка внизу работает только при комбинации Alt+Shift+клик:
    <button id="button">Нажми Alt+Shift+Click на мне!</button>

<script>
  button.onclick = function(event) {
    if (event.altKey && event.shiftKey) {
      alert('Ура!');
    }
  };
</script>
    
    OTHER EXAMPLE:
    
<div id="blueRect"></div>
 
<script>
function setColor(e){
     
    if(e.type==="mouseover")
        e.target.style.backgroundColor = "red";
    else if(e.type==="mouseout")
        e.target.style.backgroundColor = "blue";
}
let blueRect = document.getElementById("blueRect");
blueRect.addEventListener("mouseover", setColor);
blueRect.addEventListener("mouseout", setColor);
</script>
    
    
 =======================
   Координаты: clientX/Y, pageX/Y
=======================
    Все события мыши имеют координаты двух видов:
   -  Относительно окна: clientX и clientY.
   -  Относительно документа: pageX и pageY. (отсчитываются от левого верхнего угла документа).
<input onmousemove="this.value=event.clientX+':'+event.clientY" value="Наведи на меня мышь">

 Отключаем выделение текста
=======================
  До...
<b ondblclick="alert('Клик!')" onmousedown="return false">
  Сделайте двойной клик на мне
</b>
...После
   
    Предотвращаем копирование
=======================
    <div oncopy="alert('Копирование запрещено!');return false">
    
   ====================================================================================================================
 Selection и Range
  ====================================================================================================================   
   RANGE - В основе выделения лежит Range – диапазон. 
   Он представляет собой пару «граничных точек»: начало и конец диапазона.
      
      // создадим диапазон
      let range = new Range();
      
      // установим границы выделения используя range.setStart(node, offset) и range.setEnd(node, offset).
      
<p id="p">Example: <i>italic</i> and <b>bold</b></p>

<script>
  let range = new Range();

  range.setStart(p, 0);
  range.setEnd(p, 2);

  // toString, вызванный у экземпляра Range, возвращает его содержимое в виде текста (без тегов)
  alert(range); // Example: italic

  // применим этот диапазон к выделению документа (объясняется далее)
  document.getSelection().addRange(range);
</script>
  
    ==============
    Объект диапазона Range имеет следующие свойства:
    ==============   
  -  startContainer, startOffset – узел и начальное смещение  
  -  endContainer, endOffset – узел и конечное смещение,  
  - collapsed – boolean, true, если диапазон начинается и заканчивается на одном и том же месте 
  - commonAncestorContainer – ближайший общий предок всех узлов в пределах диапазона
    
    ==============
     Методы Range
    =============
      Установить начало диапазона:

    - setStart(node, offset) установить начальную границу в позицию offset в node
    - setStartBefore(node) установить начальную границу прямо перед node
   -  setStartAfter(node) установить начальную границу прямо после node

Установить конец диапазона (похожи на предыдущие методы):

    - setEnd(node, offset) установить конечную границу в позицию offset в node
    - setEndBefore(node) установить конечную границу прямо перед node
    - setEndAfter(node) установить конечную границу прямо после node
 Другие:

  -  selectNode(node) выделить node целиком
  -  selectNodeContents(node) выделить всё содержимое node
  -  collapse(toStart) если указано toStart=true, установить конечную границу в начало, 
     иначе установить начальную границу в конец, схлопывая таким образом диапазон
  -  cloneRange() создать новый диапазон с идентичными границами

Чтобы манипулировать содержимым в пределах диапазона:

  -  deleteContents() – удалить содержимое диапазона из документа
  -  extractContents() – удалить содержимое диапазона из документа и вернуть как DocumentFragment
  -  cloneContents() – склонировать содержимое диапазона и вернуть как DocumentFragment
  -  insertNode(node) – вставить node в документ в начале диапазона
  -  surroundContents(node) – обернуть node вокруг содержимого диапазона.  
     Чтобы этот метод сработал, диапазон должен содержать как открывающие, 
    так и закрывающие теги для всех элементов внутри себя: не допускаются частичные диапазоны по типу <i>abc.
 
==============
    SELECTION - обьект для визуального выделения в документе
==============
window.getSelection() или document.getSelection()
Чтобы получить всё выделение:
   - Как текст: просто вызовите document.getSelection().toString().
   - Как DOM-элементы: получите выделенные диапазоны и вызовите их метод cloneContents() 

==============  
 Свойства Selection
==============
      
    - anchorNode – узел, с которого начинается выделение,
    - anchorOffset – смещение в anchorNode, где начинается выделение,
    - focusNode – узел, на котором выделение заканчивается,
    - focusOffset – смещение в focusNode, где выделение заканчивается,
    - isCollapsed – true, если диапазон выделения пуст или не существует.
    - rangeCount – количество диапазонов в выделении, максимум 1 во всех браузерах, кроме Firefox.
==============  
 События отслеживания выделения
==============
      
   -  elem.onselectstart – когда с elem начинается выделение, например пользовать начинает двигать мышкой с зажатой кнопкой.
   -  preventDefault() отменяет начало выделения.
   - document.onselectionchange – когда выделение изменено.
     Заметьте: этот обработчик можно поставить только на document.
===========
  Методы Selection
 ==========
     Методы Selection

Методы Selection для добавления и удаления диапазонов:

   - getRangeAt(i) – взять i-ый диапазон, начиная с 0. Во всех браузерах, кроме Firefox, используется только 0.
   - addRange(range) – добавить range в выделение. Все браузеры, кроме Firefox, проигнорируют этот вызов, если в выделении уже есть диапазон.
   - removeRange(range) – удалить range из выделения.
   - removeAllRanges() – удалить все диапазоны.
   - empty() – сокращение для removeAllRanges.

Также существуют методы управления диапазонами выделения напрямую, без обращения к Range:

  -  collapse(node, offset) – заменить выделенный диапазон новым, который начинается и заканчивается на node, на позиции offset.
  -  setPosition(node, offset) – то же самое, что collapse (дублирующий метод-псевдоним).
  -  collapseToStart() – схлопнуть (заменить на пустой диапазон) к началу выделения,
  -  collapseToEnd() – схлопнуть диапазон к концу выделения,
  -  extend(node, offset) – переместить фокус выделения к данному node, с позиции offset,
  -  setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset) – заменить диапазон выделения на заданные начало anchorNode/anchorOffset и конец focusNode/focusOffset. Будет выделено всё содержимое между этими границами
  -  selectAllChildren(node) – выделить все дочерние узлы данного узла node.
  - deleteFromDocument() – удалить содержимое выделения из документа.
  -  containsNode(node, allowPartialContainment = false) – проверяет, содержит ли выделение node (частично, если второй аргумент равен true)
===========
 Выделение в Элементах форм
 ==========
   Свойства:

   - input.selectionStart – позиция начала выделения (это свойство можно изменять),
   - input.selectionEnd – позиция конца выделения (это свойство можно изменять),
   - input.selectionDirection – направление выделения, одно из: «forward» (вперёд), «backward» (назад) или «none» (
      без направления, если, к примеру, выделено с помощью двойного клика мыши).

События:

   - input.onselect – срабатывает, когда начинается выделение.

Методы:

   - input.select() – выделяет всё содержимое input (может быть textarea вместо input),
   - input.setSelectionRange(start, end, [direction]) – изменить выделение, чтобы начиналось с позиции start, 
      и заканчивалось end, в данном направлении direction (необязательный параметр).
   - input.setRangeText(replacement, [start], [end], [selectionMode]) – заменяет выделенный текст в диапазоне новым.
    Если аргументы start и end указаны, то они задают начало и конец диапазона, иначе используется текущее выделение.
    Последний аргумент, selectionMode, определяет, как будет вести себя выделение после замены текста. Возможные значения:
     -   "select" – только что вставленный текст будет выделен.
     -   "start" – диапазон выделения схлопнется прямо перед вставленным текстом (так что курсор окажется непосредственно перед ним).
     -  "end" – диапазон выделения схлопнется прямо после вставленного текста (курсор окажется сразу после него).
     -  "preserve" – пытается сохранить выделение. Значение по умолчанию.
===========
 Пример: вставка на месте курсора
 ==========

<input id="input" style="width:200px" value="Текст Текст Текст Текст Текст">
<button id="button">Вставить "ПРИВЕТ" на месте курсора</button>

<script>
  button.onclick = () => {
    input.setRangeText("ПРИВЕТ", input.selectionStart, input.selectionEnd, "end");
    input.focus();
  };
</script>
      
 ===========
Сделать что-то невыделяемым
 ==========
     1) Используйте CSS-свойство user-select: none.
      2) Предотвратить действие по умолчанию в событии onselectstart или mousedown.
      3) очистить выделение после срабатывания с помощью document.getSelection().empty()
      
 ===========
 READY EXAMPLES:
 ==========
      1) Получить выделение:
      
let selection = document.getSelection();
let cloned = /* элемент, в который мы хотим скопировать выделенные узлы */;
// затем применяем методы Range к selection.getRangeAt(0)
// или, как здесь, ко всем диапазонам, чтобы поддерживать множественное выделение
for (let i = 0; i < selection.rangeCount; i++) {
  cloned.append(selection.getRangeAt(i).cloneContents());
}
                                         
      2) Установить выделение:

let selection = document.getSelection();
// напрямую:
selection.setBaseAndExtent(...from...to...);
// или можно создать диапазон range и:
selection.removeAllRanges();
selection.addRange(range);     
                                         
    ====================================================================================================================
Движение мыши: mouseover/out, mouseenter/leave
  ====================================================================================================================  
mouseover - собтытие курсор оказывается над элементом
mouseout - событие когда курсор уходит с элемента
Когда мышь переходит с одного элемента на другой, то одного из них будет свойство target, а в другом свойство relatedTarget.

Для события mouseover:

    event.target – это элемент, на который курсор перешёл.
    event.relatedTarget – это элемент, с которого курсор ушёл (relatedTarget → target).

Для события mouseout наоборот:

    event.target – это элемент, с которого курсор ушёл.
    event.relatedTarget – это элемент, на который курсор перешёл (target → relatedTarget).
EXAMPLES:
parent.onmouseout = function(event) {
  /* event.target: внешний элемент */
};
parent.onmouseover = function(event) {
  /* event.target: внутренний элемент (всплыло) */
};
                                         
=========
// выделим элемент под мышью
table.onmouseover = function(event) {
  let target = event.target;
  target.style.background = 'pink';
};

table.onmouseout = function(event) {
  let target = event.target;
  target.style.background = '';
};
   more: https://learn.javascript.ru/mousemove-mouseover-mouseout-mouseenter-mouseleave                                       
==============                                        
Mouseenter и Mouseleave    
==============       
  Отличие от mouseover/mouseout
                                         
    1) Переходы внутри элемента, на его потомки и с них, не считаются.
    2) События mouseenter/mouseleave не всплывают.
                                       
 
====================================================
 Страница: DOMContentLoaded, load, beforeunload, unload
 ===================================================

У жизненного цикла HTML-страницы есть три важных события:

  1)  - DOMContentLoaded – браузер полностью загрузил HTML, было построено DOM-дерево, но внешние ресурсы, такие как картинки <img> и стили, могут быть ещё не загружены.
    =>document.addEventListener("DOMContentLoaded", ready);
  
  2)   load – браузер загрузил HTML и внешние ресурсы (картинки, стили и т.д.).
 => window.onload = function() {
    alert('Страница загружена');
      
   3)  beforeunload/unload – пользователь покидает страницу.
 => let analyticsData = { /* объект с собранными данными */ };
window.addEventListener("unload", function() {
  navigator.sendBeacon("/analytics", JSON.stringify(analyticsData));
};
      
Если посетитель собирается уйти со страницы или закрыть окно, 
обработчик beforeunload попросит дополнительное подтверждение.
=> window.onbeforeunload = function() {
  return false;
};
============
readyState
============
Свойство document.readyState показывает нам текущее состояние загрузки.

Есть три возможных значения:

    "loading" – документ загружается.
    "interactive" – документ был полностью прочитан.
    "complete" – документ был полностью прочитан и все ресурсы (такие как изображения) были тоже загружены.
 => 
function work() { /*...*/ }
if (document.readyState == 'loading') {
  // ещё загружается, ждём события
  document.addEventListener('DOMContentLoaded', work);
} else {
  // DOM готов!
  work();
}
============
readystatechange //генерируется при изменении состояния
============
// текущее состояние
console.log(document.readyState);
// вывести изменения состояния
document.addEventListener('readystatechange', () => console.log(document.readyState));
      
============      
 Типичный вывод:

    [1] начальный readyState:loading
    [2] readyState:interactive
    [2] DOMContentLoaded
    [3] iframe onload
    [4] img onload
    [4] readyState:complete
    [4] window onload

    ====================================================================================================================
    Клавиатура: keydown и keyup
    ====================================================================================================================
    Событие keydown происходит при нажатии клавиши, а keyup – при отпускании.
````````
keydown key=d code=KeyD
keyup key=d code=KeyD    
 ```````
 Свойство key объекта (Shift) события позволяет получить символ, а свойство code (ShiftRight) – «физический код клавиши».
 
     document.addEventListener('keydown', function(event) {
  if (event.code == 'KeyZ' && (event.ctrlKey || event.metaKey)) {
    alert('Отменить!')
  }
      
  Пример: Ввод телефонного номера:

<script>
function checkPhoneKey(key) {
  return (key >= '0' && key <= '9') || key == '+' || key == '(' || key == ')' || key == '-';
}
</script>
<input onkeydown="return checkPhoneKey(event.key)" placeholder="Введите телефон" type="tel">
      
====================================================================================================================
    Прокрутка
====================================================================================================================
 Событие прокрутки scroll позволяет реагировать на прокрутку страницы или элемента
      
   ======> функция для отображения текущей прокрутки:   
      
  window.addEventListener('scroll', function() {
  document.getElementById('showScroll').innerHTML = pageYOffset + 'px';
});
====================================================================================================================
  Загрузка ресурсов: onload и onerror
====================================================================================================================
Браузер позволяет отслеживать загрузку сторонних ресурсов: скриптов, ифреймов, изображений и др.
Для этого существуют два события:
   - load – успешная загрузка,
   - error – во время загрузки произошла ошибка.
====> Динамически создать скрипт:

let script = document.createElement('script');
script.src = "my.js";
document.head.append(script);

script.onload = function() {         // load - срабатывает после того, как скрипт был загружен и выполнен.
  // в скрипте создаётся вспомогательная функция с именем "_"
  alert(_); // функция доступна
};
    
script.onerror = function() {
  alert("Error loading " + this.src); // Ошибка загрузки https://example.com/404.js
};
      
Чтобы разрешить кросс-доменный доступ, нам нужно поставить тегу script атрибут crossorigin, и, 
        кроме того, удалённый сервер должен поставить специальные заголовки.

===== > Кросс Доменный доступ:
      Существует три уровня кросс-доменного доступа:

  - Атрибут crossorigin отсутствует – доступ запрещён.
  - crossorigin="anonymous" – доступ разрешён, если сервер отвечает с заголовком 
    Access-Control-Allow-Origin со значениями * или наш домен. 
    Браузер не отправляет авторизационную информацию и куки на удалённый сервер.
  - crossorigin="use-credentials" – доступ разрешён, если сервер отвечает с заголовками Access-Control-Allow-Origin
    со значением наш домен и Access-Control-Allow-Credentials: true. 
    Браузер отправляет авторизационную информацию и куки на удалённый сервер.
      
  ====================================================================================================================
BUBLE EVENTS | Всплытие и погружение
  ==================================================================================================================== 
      
      Самый глубокий элемент, который вызывает событие, называется целевым элементом, и он доступен через event.target
    
    Отличия от this (=event.currentTarget):
    - event.target – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен.
    - this – это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.
      
    // event.stopPropagation()  - остановка события

<body onclick="alert(`сюда всплытие не дойдёт`)">
<button onclick="event.stopPropagation()">Кликни меня</button>
</body>

- event.stopPropagation() препятствует продвижению события дальше, но на текущем элементе все обработчики будут вызваны.
- event.stopImmediatePropagation()  остановить обработку на текущем ивенте

 Стандарт DOM Events описывает 3 фазы прохода события:

   1) Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.
   2) Фаза цели (target phase) – событие достигло целевого(исходного) элемента.
   3) Фаза всплытия (bubbling stage) – событие начинает всплывать.

   Чтобы поймать событие на стадии погружения, нужно использовать третий аргумент capture вот так:
elem.addEventListener(..., {capture: true})
// или просто "true", как сокращение для {capture: true}
elem.addEventListener(..., true)

Существуют два варианта значений опции capture:

    Если аргумент false (по умолчанию), то событие будет поймано при всплытии.
    Если аргумент true, то событие будет перехвачено при погружении.
  ====================================================================================================================
Действия браузера по умолчанию
  ==================================================================================================================== 
Действий браузера по умолчанию достаточно много:

  -   mousedown – начинает выделять текст (если двигать мышкой).
  -  click на <input type="checkbox"> – ставит или убирает галочку в input.
  -  submit – при нажатии на <input type="submit"> или при нажатии клавиши Enter в форме данные отправляются на сервер.
  -  keydown – при нажатии клавиши в поле ввода появляется символ.
  -   contextmenu – при правом клике показывается контекстное меню браузера.
    …и многие другие…

      === Отмена действия браузера
      
Есть два способа отменить действие браузера:
   -  Основной способ – это воспользоваться объектом event. Для отмены действия браузера 
      существует стандартный метод event.preventDefault().
   -  Если же обработчик назначен через on<событие> (не через addEventListener), то также можно вернуть false из обработчика
    
 EX = переход не произойдет:
      
<a href="/" onclick="return false">Нажми здесь</a>
или
<a href="/" onclick="event.preventDefault()">здесь</a>
      
 OR:
 menu.onclick = function(event) {
 if (event.target.nodeName != 'A') return;       <======
 let href = event.target.getAttribute('href');
 alert( href ); // может быть подгрузка с сервера, генерация интерфейса и т.п.
  return false; // отменить действие браузера (переход по ссылке)
};
    
 Необязательная опция passive: true для addEventListener сигнализирует браузеру,
 что обработчик не собирается выполнять preventDefault().
  
====> event.defaultPrevented
  Свойство event.defaultPrevented установлено в true, если действие по умолчанию было предотвращено, и false, если нет.
   elem.oncontextmenu = function(event) {
    event.preventDefault();
    alert("Контекстное меню кнопки");
  };   
      
    ====================================================================================================================
Делегирование событий
  ====================================================================================================================  
      Родитель ловит ивент в child => в данном случае ивент на таблице ловит клик по ячейке:
      КОД:
<script>
let selectedTd;
table.onclick = function(event) {
  let target = event.target; // где был клик?
  if (target.tagName != 'TD') return; // не на TD? тогда не интересует
  highlight(target); // подсветить TD
};
function highlight(td) {
  if (selectedTd) { // убрать существующую подсветку, если есть
    selectedTd.classList.remove('highlight');
  }
  selectedTd = td;
  selectedTd.classList.add('highlight'); // подсветить новый td
}
</script>
      
   ==> увидеть был ли клик внутри дива в ячейке:

 table.onclick = function(event) {
  let td = event.target.closest('td'); //(1) <=elem.closest(selector) возвращает ближайшего предка, соответствующего селектору.
  if (!td) return; // (2)<== Если event.target не содержится внутри элемента <td>, то вызов вернёт null
  if (!table.contains(td)) return; // (3)   <== Если таблицы вложенные, event.target может содержать элемент <td>, 
                                             находящийся вне текущей таблицы. В таких случаях мы должны проверить
                                            действительно ли это <td> нашей таблицы.
     highlight(td); // (4) <== подсвечиваем его.
};
====> Удаление блока пример:
  <div id="container">
  <div class="pane">
      <h3>Кошка</h3>
      <p>Кошка, или домашняя кошка (лат. Félis silvéstris cátus), — домашнее животное, одно из наиболее популярных (наряду с собакой) "животных-компаньонов". С точки зрения научной систематики, домашняя кошка — млекопитающее семейства кошачьих отряда хищных. Ранее домашнюю кошку нередко рассматривали как отдельный биологический вид.
      </p>
      <button class="remove-button">[x]</button>
    </div>
  </div>
 </div>
  <script>
    container.onclick = function(event) {
      if (event.target.className != 'remove-button') return;

      let pane = event.target.closest('.pane');
      pane.remove();
    };
  </script>
  ====================================================================================================================
  Генерация пользовательских событий
  ====================================================================================================================  
     ==> Конструктор Event
      let event = new Event(type[, options]);
   Где:
  -  type – тип события, строка, например "click" или же любой придуманный нами – "my-event".
  -  options – объект с двумя необязательными свойствами:
        bubbles: true/false – если true, тогда событие всплывает.
        cancelable: true/false – если true, тогда можно отменить действие по умолчанию. 
По умолчанию оба свойства установлены в false: {bubbles: false, cancelable: false}.
 
 После того, как объект события создан, мы должны запустить его на элементе, 
 вызвав метод elem.dispatchEvent(event)
      
==> Example
      
<button id="elem" onclick="alert('Клик!');">Автоклик</button>

<script>
  let event = new Event("click");
  elem.dispatchEvent(event);
</script>
 Свойство event.isTrusted принимает значение true для событий, 
 порождаемых реальными действиями пользователя, и false для генерируемых кодом.     
  
  ==> CustomEvent
 Для генерации событий совершенно новых типов, таких как "hello", следует использовать конструктор new CustomEvent.     
 есть дополнительное свойство detail, в котором можно указывать информацию для передачи в событие.
      
 elem.dispatchEvent(new CustomEvent("hello", {
 detail: { name: "Вася" }  
      
      
      
      
