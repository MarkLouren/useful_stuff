==== Document Object Model, сокращённо DOM – объектная модель документа, которая представляет все содержимое 
страницы в виде объектов, которые можно менять.

SPEC: https://dom.spec.whatwg.org.
http://software.hixie.ch/utilities/js/live-dom-viewer/ 

==== Объектная модель браузера (Browser Object Model, BOM) – это дополнительные объекты, 
предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.

              <!-- NAVIGATION -->

getElementsBy* - возвращает живую коллекцию
 querySelectorAll - возыращает статическую коллекцию


=> <HTML> = document.documentElement 
=> <BODY> = document.body

=> elem.childNodes[0] === elem.firstChild
=> elem.childNodes[elem.childNodes.length - 1] === elem.lastChild
  
  -  children – только дочерние узлы-элементы, то есть соответствующие тегам.
  -  firstElementChild, lastElementChild – соответственно, первый и последний дети-элементы.
  -  previousElementSibling, nextElementSibling – соседи-элементы.
  -  parentElement – родитель-элемент.
  
=> document.getElementbyId(id)
// получить элемент  => let elem = document.getElementById('elem');
=> elem.querySelectorAll(css),// он возвращает все элементы внутри elem, удовлетворяющие данному CSS-селектору.
            EX:  let elements = document.querySelectorAll('ul > li:last-child');
=> elem.querySelector(css) //возвращает первый элемент, соответствующий данному CSS-селектору. 
=> elem.matches(css) // ничего не ищет, а проверяет, удовлетворяет ли elem CSS-селектору, и возвращает true или false.

EXAMPLE:
  <a href="http://example.com/file.zip">...</a>
<a href="http://ya.ru">...</a>
<script>
  // может быть любая коллекция вместо document.body.children
  for (let elem of document.body.children) {
    if (elem.matches('a[href$="zip"]')) {
      alert("Ссылка на архив: " + elem.href );
    }
  }
</script>
=>  elem.closest(css) // ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент также включается в поиск.
=> elem.getElementsByTagName(tag) //ищет элементы с данным тегом и возвращает их коллекцию. Передав "*" вместо тега, можно получить всех потомков.
=> elem.getElementsByClassName(className)  //возвращает элементы, которые имеют данный CSS-класс.
=> document.getElementsByName(name) // возвращает элементы с заданным атрибутом name.
 
=> elemA.contains(elemB) вернёт true, если elemB находится внутри elemA (elemB потомок elemA) или когда elemA==elemB.
 
 <!-- TABLES -->
 
TABLE

    table.rows – коллекция строк TR таблицы.
    table.caption/tHead/tFoot – ссылки на элементы таблицы CAPTION, THEAD, TFOOT.
    table.tBodies – коллекция элементов таблицы TBODY, по спецификации их может быть несколько.

THEAD/TFOOT/TBODY

   tbody.rows – коллекция строк TR секции.
TR
   tr.cells – коллекция ячеек TD/TH
    tr.sectionRowIndex – номер строки в текущей секции THEAD/TBODY
    tr.rowIndex – номер строки в таблице

TD/TH
    td.cellIndex – номер ячейки в строке


    
        <!-- For -->
    
    
<body>
  <div>Начало</div>

  <ul>
    <li>Информация</li>
  </ul>

  <div>Конец</div>

  <script>
    for (var i = 0; i < document.body.childNodes.length; i++) {
      alert( document.body.childNodes[i] ); // Text, DIV, Text, UL, ..., SCRIPT
    }
  </script>
  ...
</body>
 
  
                   <!-- Как примениить Метод Массива к DOM -->
 
 
 <!-- V1 -- Применить метод массива через call/apply -->
  
var elems = document.documentElement.childNodes;

[].forEach.call(elems, function(elem) {
  alert( elem ); // HEAD, текст, BODY
});
  
<!-- При помощи Array.prototype.slice сделать из коллекции массив. -->
 
 var elems = document.documentElement.childNodes;
elems = Array.prototype.slice.call(elems); // теперь elems - массив

elems.forEach(function(elem) {
  alert( elem.tagName ); // HEAD, текст, BODY
});
   
 
                 <!--  Доступ к АТРИБУТАМ DOM элемента -->
 
 Свойства 	                        Атрибуты
 
=> Любое значение                  => 	Строка
=> Названия регистрозависимы 	     =>  Не чувствительны к регистру
=> Не видны в innerHTML 	          =>  Видны в innerHTML
 
 
    elem.hasAttribute(name) – проверяет наличие атрибута
    elem.getAttribute(name) – получает значение атрибута
    elem.setAttribute(name, value) – устанавливает атрибут
    elem.removeAttribute(name) – удаляет атрибут
    elem.attributes - получить все атрибуты элемента
 
 EXAMPLE:
 
 <body>
  <div id="elem" about="Elephant"></div>

  <script>
    alert( elem.getAttribute('About') ); // (1) 'Elephant', атрибут получен

    elem.setAttribute('Test', 123); // (2) атрибут Test установлен
    alert( document.body.innerHTML ); // (3) в HTML видны все атрибуты!

    var attrs = elem.attributes; // (4) можно получить коллекцию атрибутов
    for (var i = 0; i < attrs.length; i++) {
      alert( attrs[i].name + " = " + attrs[i].value );
    }
  </script>
</body>
 
                          <!-- ClassName -->
 
 <body class="main page">
  <script>
    // прочитать класс элемента
    alert( document.body.className ); // main page

    // поменять класс элемента
    document.body.className = "class1 class2";
  </script>
</body>
 /////////  кроме className, в современных браузерах есть свойство classList.
 
 Методы classList:

    elem.classList.contains("class") – возвращает true/false, в зависимости от того, есть ли у элемента класс class.
    elem.classList.add/remove("class") – добавляет/удаляет класс class
    elem.classList.toggle("class") – если класса class нет, добавляет его, если есть – удаляет.

Кроме того, можно перебрать классы через for, так как classList – это псевдо-массив.
 
 
                   <!-- DATA -->
С помощью нестандартных атрибутов можно привязать к элементу данные, которые будут доступны в JavaScript.
Как правило, это делается при помощи атрибутов с названиями, начинающимися на data-
 
 EXAMPLE DATA, DATASET
 
 <div id="elem" data-about="Elephant" data-user-location="street">
  По улице прошёлся слон. Весьма красив и толст был он.
</div>
<script>
  alert( elem.getAttribute('data-about') ); // Elephant
  alert( elem.getAttribute('data-user-location') ); // street
 
   alert( elem.dataset.about ); // Elephant
  alert( elem.dataset.userLocation ); // street
</script>
 
====================================================
 Свойства узлов: тип, тег и содержимое
 ===================================================
 
 Существуют следующие классы:
 
 => EventTarget – это корневой «абстрактный» класс. Объекты этого класса никогда не создаются.
 Он служит основой, благодаря которой все DOM-узлы поддерживают так называемые «события», о которых мы поговорим позже.

 => Node – также является «абстрактным» классом, и служит основой для DOM-узлов. Он обеспечивает базовую функциональность: 
 parentNode, nextSibling, childNodes и т.д. (это геттеры). Объекты класса Node никогда не создаются. 
 Но есть определённые классы узлов, которые наследуют от него: 
 Text – для текстовых узлов, Element – для узлов-элементов и более экзотический Comment – для узлов-комментариев.
 
 =>Element – это базовый класс для DOM-элементов. Он обеспечивает навигацию на уровне элементов:
 nextElementSibling, children и методы поиска: getElementsByTagName, querySelector. 
 Браузер поддерживает не только HTML, но также XML и SVG. 
 
 =>HTMLElement – является базовым классом для всех остальных HTML-элементов. От него наследуют конкретные элементы:

  -   HTMLInputElement – класс для тега <input>,
  -   HTMLBodyElement – класс для тега <body>,
  -   HTMLAnchorElement – класс для тега <a>,
    …и т.д, каждому тегу соответствует свой класс, который предоставляет определённые свойства и методы.


 Класс Element служит базой для следующих классов: SVGElement, XMLElement и HTMLElement
 

 
 Рассмотрим DOM-объект для тега <input>. Он принадлежит классу HTMLInputElement.

Он получает свойства и методы из (в порядке наследования):

    HTMLInputElement – этот класс предоставляет специфичные для элементов формы свойства,
    HTMLElement – предоставляет общие для HTML-элементов методы (и геттеры/сеттеры),
    Element – предоставляет типовые методы элемента,
    Node – предоставляет общие свойства DOM-узлов,
    EventTarget – обеспечивает поддержку событий (поговорим о них дальше),
    …и, наконец, он наследует от Object, поэтому доступны также методы «обычного объекта», такие как hasOwnProperty.
 
 
 
 <!--  узнать имя класса DOM-узла  -->
 1) alert( document.body.constructor.name ); // HTMLBodyElement
 2)alert( document.body ); // [object HTMLBodyElement]
 3) alert( document.body instanceof HTMLBodyElement ); // true
 4) nodeType - Свойство nodeType позволяет узнать тип DOM-узла. Его значение – числовое: 
 1 для элементов,3 для текстовых узлов, и т.д. Только для чтения.
 
 Получив DOM-узел, мы можем узнать имя его тега из свойств nodeName и tagName:
 
 alert( document.body.nodeName ); // BODY
 alert( document.body.tagName ); // BODY
============= 
Главные свойства DOM-узла:
=============
 -> nodeType
 -> nodeName/tagName //возвращает название тега
 -> innerHTML //Внутреннее HTML-содержимое узла-элемента. Можно изменять.
 --> innerText // 
 -> outerHTML //Полный HTML узла-элемента. Запись в elem.outerHTML не меняет elem
 -> nodeValue/data // Содержимое узла-неэлемента (текст, комментарий). 
 -> textContent //Текст внутри элемента: HTML за вычетом всех <тегов>. 
 -> hidden // огда значение установлено в true, делает то же самое, что и CSS display:none
 В зависимости от своего класса DOM-узлы имеют и другие свойства
 
  
  <-- STYLES -->
    ul.style.color='green'
  
    ====================================================================================================================
    Изменение документа
    =====================================================================================================================
    
    ===> Cоздание DOM узла:
    
    1) let div = document.createElement('div'); // создает новый элемент с заданым тегом
    2) let textNode = document.createTextNode('А вот и я');    //Cоздает новый текстовый узел с заданным текстом
    
    =====> Методы вставки: -  методы могут использоваться только для вставки DOM-узлов или текстовых фрагментов.
   
    - node.append(...nodes or strings) – добавляет узлы или строки в конец node,
    - node.prepend(...nodes or strings) – вставляет узлы или строки в начало node,
    - node.before(...nodes or strings) –- вставляет узлы или строки до node,
    -  node.after(...nodes or strings) –- вставляет узлы или строки после node,
    -  node.replaceWith(...nodes or strings) –- заменяет node заданными узлами или строками.
   
    =====> Пример:
<ol id="ol">
  <li>0</li>
  <li>1</li>
  <li>2</li>
</ol>

<script>
  
  ol.before('before'); // вставить строку "before" перед <ol>
  ol.after('after'); // вставить строку "after" после <ol>

  let liFirst = document.createElement('li');
  liFirst.innerHTML = 'prepend';
  ol.prepend(liFirst); // вставить liFirst в начало <ol>

  let liLast = document.createElement('li');
  liLast.innerHTML = 'append';
  ol.append(liLast); // вставить liLast в конец <ol>
  
</script>
    
    =========> insertAdjacentHTML/Text/ - для вставки HTML кода
    
    elem.insertAdjacentHTML(where, html) - вставляет HTML
    elem.insertAdjacentText(where, text) – такой же синтаксис, но строка text вставляется «как текст», вместо HTML
    elem.insertAdjacentElement(where, elem) – такой же синтаксис, но вставляет элемент elem
    
    
   -  "beforebegin" – вставить html непосредственно перед elem,
   -  "afterbegin" – вставить html в начало elem,
   -  "beforeend" – вставить html в конец elem,
   -   "afterend" – вставить html непосредственно после elem.
    
  Пример:
    
<div id="div"></div>
<script>
  div.insertAdjacentHTML('beforebegin', '<p>Привет</p>');
  div.insertAdjacentHTML('afterend', '<p>Пока</p>');
</script>

    =======> Удаление узла:
    
   node.remove()
    setTimeout(() => div.remove(), 1000);
   
    =======> Перестановка:
    
<div id="first">Первый</div>
<div id="second">Второй</div>
<script>
  // нет необходимости вызывать метод remove
  second.after(first); // берёт #second и после него вставляет #first
</script>
    
    =========>  Клонирование узлов: cloneNode
    
   elem.cloneNode(true) создаёт «глубокий» клон элемента – со всеми атрибутами и дочерними элементами. 
   Если мы вызовем elem.cloneNode(false), тогда клон будет без дочерних элементов.
    
   ПРИМЕР:
    
 <div class="alert" id="div">
  <strong>Всем привет!</strong> Вы прочитали важное сообщение.
</div>

<script>
  let div2 = div.cloneNode(true); // клонировать сообщение
  div2.querySelector('strong').innerHTML = 'Всем пока!'; // изменить клонированный элемент

  div.after(div2); // показать клонированный элемент после существующего div
</script>
    
    =======> DocumentFragment + Устаревшие методы вставки/удаления
    DocumentFragment является специальным DOM-узлом, который служит обёрткой для передачи списков узлов.
- parent.appendChild(node)
- parent.insertBefore(node, nextSibling)
- parent.removeChild(node)
- parent.replaceChild(newElem, node)
    
    ===>  document.write('<b>Привет из JS</b>');
    document.write(html) записывает html на страницу «прямо здесь и сейчас». 
    Чтобы добавить HTML на страницу до завершения её загрузки:
    
    ====================================================================================================================
    Стили и Классы
    ====================================================================================================================

let top = /* сложные расчёты */;
let left = /* сложные расчёты */;

elem.style.left = left; // например, '123px', значение вычисляется во время работы скрипта
elem.style.top = top; // например, '456px'
    
    
    ====> className и classList
    ==> elem.className,  заменяет всю строку с классами
    
<body class="main page">
  <script>
    alert(document.body.className); // main page
  </script>
</body>
    
    ==> elem.classList – это специальный объект с методами для добавления/удаления одного класса.
  
  <body class="main page">
  <script>
    // добавление класса
    document.body.classList.add('article');

    alert(document.body.className); // main page article
  </script>
</body>
    
   ====== Методы classList:======

  -  elem.classList.add/remove("class") – добавить/удалить класс.
  -  elem.classList.toggle("class") – добавить класс, если его нет, иначе удалить.
  -  elem.classList.contains("class") – проверка наличия класса, возвращает true/false.

Кроме того, classList является перебираемым, поэтому можно перечислить все классы при помощи for..of:
    
   <body class="main page">
  <script>
    for (let name of document.body.classList) {
      alert(name); // main, затем page
    }
  </script>
</body>
    
    =======> elem.style  - это объект, который соответствует тому, что написано в атрибуте "style". 
   
    Для свойства из нескольких слов используется camelCase:

background-color  => elem.style.backgroundColor
z-index           => elem.style.zIndex
border-left-width => elem.style.borderLeftWidth
-moz-border-radius => button.style.MozBorderRadius = '5px';
 
 ===> Сброс стилей

    EX: 
document.body.style.backgroundColor = prompt('background color?', 'green');
document.body.style.display = "none"; // скрыть
    
    Если мы установим в style.display пустую строку, то браузер применит CSS-классы и встроенные стили, 
    как если бы такого свойства style.display вообще не было.
    
 ===> style.cssText  - Для задания нескольких стилей в одной строке
    
    div.style.cssText=`color: red !important;
    background-color: yellow;
    width: 100px;
    text-align: center;
    `;
    То же самое можно сделать установкой атрибута: div.setAttribute('style', 'color: red...')

 ====>  getComputedStyle
   
    getComputedStyle(element, [pseudo])
  -   element - Элемент, значения для которого нужно получить
  -   pseudo - Указывается, если нужен стиль псевдоэлемента, 
    например ::before. Пустая строка или отсутствие аргумента означают сам элемент.
    
    EXAMPLE: 
    
<head>
  <style> body { color: red; margin: 5px } </style>
</head>
<body>
 <script>
    let computedStyle = getComputedStyle(document.body);
    // сейчас мы можем прочитать отступ и цвет
    alert( computedStyle.marginTop ); // 5px
    alert( computedStyle.color ); // rgb(255, 0, 0)
  </script>

</body>
    
    
 =====================================================================

Есть две концепции в CSS:

=> Вычисленное (computed) значение – это то, которое получено после применения всех CSS-правил и CSS-наследования.
Например, height:1em или font-size:125%.
=> Окончательное (resolved) значение – непосредственно применяемое к элементу. 
    Значения 1em или 125% являются относительными. Браузер берёт вычисленное значение и делает 
    все единицы измерения фиксированными и абсолютными, например, height:20px or font-size:16px.
    Для геометрических свойств разрешённые значения могут иметь плавающую точку, например, width:50.5px.
    
        
    ====================================================================================================================
    Размеры и прокрутка элементов
    ====================================================================================================================
    
    ==> offsetParent, offsetLeft/Top
    В свойстве offsetParent находится предок элемента, 
    который используется внутри браузера для вычисления координат при рендеринге.
    
    Свойства offsetLeft/offsetTop содержат координаты x/y относительно верхнего левого угла offsetParent.
    
    EXAMPLE:
 <main style="position: relative" id="main">
  <article>
    <div id="example" style="position: absolute; left: 180px; top: 180px">...</div>
  </article>
</main>
<script>
  alert(example.offsetParent.id); // main
  alert(example.offsetLeft); // 180 (обратите внимание: число, а не строка "180px")
  alert(example.offsetTop); // 180
</script>
    
    
    === Существует несколько ситуаций, когда offsetParent равно null:

    Для скрытых элементов (с CSS-свойством display:none или когда его нет в документе).
    Для элементов <body> и <html>.
    Для элементов с position:fixed.
    
    ====> offsetWidth/Height
    
    Они содержат «внешнюю» ширину/высоту элемента, то есть его полный размер, включая рамки.
offsetWidth = 390 – внешняя ширина блока, её можно получить сложением CSS-ширины (300px), внутренних отступов (2 * 20px) и рамок (2 * 25px).
offsetHeight = 290 – внешняя высота блока
  
    ===> clientTop/Left
    
Внутри элемента у нас рамки (border).
Для них есть свойства-метрики clientTop и clientLeft.
В нашем примере:
-  clientLeft = 25 – ширина левой рамки
-  clientTop = 25 – ширина верхней рамки

   ===> clientWidth/Height
Эти свойства – размер области внутри рамок элемента.
Они включают в себя ширину области содержимого вместе с внутренними отступами padding, но без прокрутки
- Если нет внутренних отступов padding, то clientWidth/Height в точности равны размеру области 
    содержимого внутри рамок и полосы прокрутки (если она есть).
   
  ===> scrollWidth/Height
Эти свойства – как clientWidth/clientHeight, но также включают в себя прокрученную (которую не видно) часть элемента.  
Эти свойства можно использовать, чтобы «распахнуть» элемент на всю ширину/высоту.
  EXAMPLE:
  // распахнуть элемент на всю высоту
element.style.height = `${element.scrollHeight}px`
  
  ===>scrollLeft/scrollTop
  Свойства scrollLeft/scrollTop – ширина/высота невидимой, прокрученной в данный момент, части элемента слева и сверху.
  Другими словами, свойство scrollTop – это «сколько уже прокручено вверх».
  => В отличие от большинства свойств, которые доступны только для чтения, 
 значения scrollLeft/scrollTop можно изменять, и браузер выполнит прокрутку элемента…
 При клике на следующий элемент будет выполняться код elem.scrollTop += 10. 
 Поэтому он будет прокручиваться на 10px вниз.
    
    
 ====================================================
 Размеры и прокрутка окна
 ===================================================
    Чтобы получить ширину/высоту окна, можно взять свойства clientWidth/clientHeight из document.documentElement

alert( window.innerWidth ); // полная ширина окна
alert( document.documentElement.clientWidth ); // ширина окна за вычетом полосы прокрутки
  
 ==== Чтобы надежно получить высоту документа:
    
  let scrollHeight = Math.max(
  document.body.scrollHeight, document.documentElement.scrollHeight,
  document.body.offsetHeight, document.documentElement.offsetHeight,
  document.body.clientHeight, document.documentElement.clientHeight
);

alert('Полная высота документа с прокручиваемой частью: ' + scrollHeight);

===== текущая прокрутка
alert('Текущая прокрутка сверху: ' + window.pageYOffset);
alert('Текущая прокрутка слева: ' + window.pageXOffset);

====Изменить текущую прокрутку:

window.scrollTo(pageX,pageY) – абсолютные координаты,
window.scrollBy(x,y) – прокрутка относительно текущего места,
elem.scrollIntoView(top) – прокрутить страницу так, чтобы сделать elem видимым (выровнять относительно верхней/нижней части окна

 ==== Запретить прокрутку
    
  Чтобы запретить прокрутку страницы, достаточно установить document.body.style.overflow = "hidden".
    
  ====================================================================================================================
  Координаты
  ==================================================================================================================== 
Большинство соответствующих методов JavaScript работают в одной из двух указанных ниже систем координат:
    1) Относительно окна браузера – как position:fixed, отсчёт идёт от верхнего левого угла окна.
    мы будем обозначать эти координаты как clientX/clientY
    2) Относительно документа – как position:absolute на уровне документа, отсчёт идёт от верхнего левого угла документа.
    мы будем обозначать эти координаты как pageX/pageY.
    
==>  Метод elem.getBoundingClientRect() возвращает координаты в контексте окна для минимального по размеру прямоугольника, 
который заключает в себе элемент elem, в виде объекта встроенного класса DOMRect.
      
  let coords = elem.getBoundingClientRect() 
  message.style.left = coords.left + "px";
  message.style.top = coords.bottom + "px";
    
    Основные свойства объекта типа DOMRect:

    x/y – X/Y-координаты начала прямоугольника относительно окна,
    width/height – ширина/высота прямоугольника (могут быть отрицательными).

Дополнительные, «зависимые», свойства:

    top/bottom – Y-координата верхней/нижней границы прямоугольника,
    left/right – X-координата левой/правой границы прямоугольника.
==>
    left = x
    top = y
    right = x + width
    bottom = y + height
Координаты могут быть отрицательными. Например, если страница прокручена так, что элемент elem ушёл вверх за пределы окна,
то вызов elem.getBoundingClientRect().top вернёт отрицательное значение.
  
  ======> elementFromPoint(x, y)
    
   Вызов document.elementFromPoint(x, y) возвращает самый глубоко вложенный элемент в окне,
   находящийся по координатам (x, y).
 
   let elem = document.elementFromPoint(x, y);
    
    EXAMPLE: код ниже выделяет с помощью стилей и выводит имя тега элемента, который сейчас в центре окна браузера:

let centerX = document.documentElement.clientWidth / 2;
let centerY = document.documentElement.clientHeight / 2;

let elem = document.elementFromPoint(centerX, centerY);

elem.style.background = "red";
alert(elem.tagName);
    
    
    
    
